package rv32

import chisel3._
import chisel3.util._

object Instructions {
  // U-type instructions
  val auipc = BitPat("b??????? ????? ????? ??? ????? 00101 11") // Add Upper Immediate to PC: rd = pc + imm
  val lui   = BitPat("b??????? ????? ????? ??? ????? 01101 11") // Load Upper Immediate: rd = imm

  // I-type instructions
  val lw    = BitPat("b??????? ????? ????? 010 ????? 00000 11") // Load Word: rd = mem[rs1 + imm]
  val lbu   = BitPat("b??????? ????? ????? 100 ????? 00000 11") // Load Byte Unsigned: rd = mem[rs1 + imm] (zero extend)
  val lb    = BitPat("b??????? ????? ????? 000 ????? 00000 11") // Load Byte: rd = mem[rs1 + imm] (sign extend)
  val lh    = BitPat("b??????? ????? ????? 001 ????? 00000 11") // Load Half: rd = mem[rs1 + imm] (sign extend)
  val lhu   = BitPat("b??????? ????? ????? 101 ????? 00000 11") // Load Half Unsigned: rd = mem[rs1 + imm] (zero extend)
  val andi  = BitPat("b??????? ????? ????? 111 ????? 00100 11") // AND Immediate: rd = rs1 & imm
  val addi  = BitPat("b??????? ????? ????? 000 ????? 00100 11") // Add Immediate: rd = rs1 + imm
  val xori  = BitPat("b??????? ????? ????? 100 ????? 00100 11") // XOR Immediate: rd = rs1 ^ imm
  val ori   = BitPat("b??????? ????? ????? 110 ????? 00100 11") // OR Immediate: rd = rs1 | imm
  val srai  = BitPat("b0100000 ????? ????? 101 ????? 00100 11") // Shift Right Arithmetic Immediate: rd = rs1 >> imm (arithmetic)
  val srli  = BitPat("b0000000 ????? ????? 101 ????? 00100 11") // Shift Right Logical Immediate: rd = rs1 >> imm (logical)
  val slli  = BitPat("b0000000 ????? ????? 001 ????? 00100 11") // Shift Left Logical Immediate: rd = rs1 << imm
  val sltiu = BitPat("b??????? ????? ????? 011 ????? 00100 11") // Set Less Than Immediate Unsigned: rd = (rs1 < imm) ? 1 : 0 (unsigned)
  val slti  = BitPat("b??????? ????? ????? 010 ????? 00100 11") // Set Less Than Immediate: rd = (rs1 < imm) ? 1 : 0 (signed)
  val jalr  = BitPat("b??????? ????? ????? 000 ????? 11001 11") // Jump And Link Register: rd = pc + 4; pc = (rs1 + imm) & ~1

  // S-type instructions
  val sb    = BitPat("b??????? ????? ????? 000 ????? 01000 11") // Store Byte: mem[rs1 + imm] = rs2[7:0]
  val sw    = BitPat("b??????? ????? ????? 010 ????? 01000 11") // Store Word: mem[rs1 + imm] = rs2
  val sh    = BitPat("b??????? ????? ????? 001 ????? 01000 11") // Store Half: mem[rs1 + imm] = rs2[15:0]

  // B-type instructions
  val blt   = BitPat("b??????? ????? ????? 100 ????? 11000 11") // Branch Less Than: if(rs1 < rs2) pc += imm (signed)
  val bltu  = BitPat("b??????? ????? ????? 110 ????? 11000 11") // Branch Less Than Unsigned: if(rs1 < rs2) pc += imm (unsigned)
  val bge   = BitPat("b??????? ????? ????? 101 ????? 11000 11") // Branch Greater Equal: if(rs1 >= rs2) pc += imm (signed)
  val bgeu  = BitPat("b??????? ????? ????? 111 ????? 11000 11") // Branch Greater Equal Unsigned: if(rs1 >= rs2) pc += imm (unsigned)
  val beq   = BitPat("b??????? ????? ????? 000 ????? 11000 11") // Branch Equal: if(rs1 == rs2) pc += imm
  val bne   = BitPat("b??????? ????? ????? 001 ????? 11000 11") // Branch Not Equal: if(rs1 != rs2) pc += imm

  // R-type instructions
  val sra   = BitPat("b0100000 ????? ????? 101 ????? 01100 11") // Shift Right Arithmetic: rd = rs1 >> rs2 (arithmetic)
  val srl   = BitPat("b0000000 ????? ????? 101 ????? 01100 11") // Shift Right Logical: rd = rs1 >> rs2 (logical)
  val rem   = BitPat("b0000001 ????? ????? 110 ????? 01100 11") // Remainder: rd = rs1 % rs2 (signed)
  val remu  = BitPat("b0000001 ????? ????? 111 ????? 01100 11") // Remainder Unsigned: rd = rs1 % rs2 (unsigned)
  val divu  = BitPat("b0000001 ????? ????? 101 ????? 01100 11") // Divide Unsigned: rd = rs1 / rs2 (unsigned)
  val div   = BitPat("b0000001 ????? ????? 100 ????? 01100 11") // Divide: rd = rs1 / rs2 (signed)
  val mul   = BitPat("b0000001 ????? ????? 000 ????? 01100 11") // Multiply: rd = rs1 * rs2
  val mulh  = BitPat("b0000001 ????? ????? 001 ????? 01100 11") // Multiply High: rd = (rs1 * rs2) >> 32 (signed)
  val mulhu = BitPat("b0000001 ????? ????? 011 ????? 01100 11") // Multiply High Unsigned: rd = (rs1 * rs2) >> 32 (unsigned)
  val and   = BitPat("b0000000 ????? ????? 111 ????? 01100 11") // AND: rd = rs1 & rs2
  val sll   = BitPat("b0000000 ????? ????? 001 ????? 01100 11") // Shift Left Logical: rd = rs1 << rs2
  val add   = BitPat("b0000000 ????? ????? 000 ????? 01100 11") // Add: rd = rs1 + rs2
  val sub   = BitPat("b0100000 ????? ????? 000 ????? 01100 11") // Subtract: rd = rs1 - rs2
  val sltu  = BitPat("b0000000 ????? ????? 011 ????? 01100 11") // Set Less Than Unsigned: rd = (rs1 < rs2) ? 1 : 0 (unsigned)
  val slt   = BitPat("b0000000 ????? ????? 010 ????? 01100 11") // Set Less Than: rd = (rs1 < rs2) ? 1 : 0 (signed)
  val xor   = BitPat("b0000000 ????? ????? 100 ????? 01100 11") // XOR: rd = rs1 ^ rs2
  val or    = BitPat("b0000000 ????? ????? 110 ????? 01100 11") // OR: rd = rs1 | rs2

  // J-type instructions
  val jal   = BitPat("b??????? ????? ????? ??? ????? 11011 11") // Jump And Link: rd = pc + 4; pc += imm

  // System instructions
  val ebreak = BitPat("b0000000 00001 00000 000 00000 11100 11") // Environment Break: Pause execution and transfer control to debugger
}

object Parameters {
  val WORD_LEN = 32
  val START_PC = 0x80000000.U(WORD_LEN.W)
  val ADDR_LEN = 5

  val EXE_FUN_LEN = 5
  val ALU_NONE = 0.U(EXE_FUN_LEN.W)
  val ALU_SRA = 1.U(EXE_FUN_LEN.W)
  val ALU_SRL = 2.U(EXE_FUN_LEN.W)
  val ALU_REM = 3.U(EXE_FUN_LEN.W)
  val ALU_REMU = 4.U(EXE_FUN_LEN.W)
  val ALU_DIVU = 5.U(EXE_FUN_LEN.W)
  val ALU_DIV = 6.U(EXE_FUN_LEN.W)
  val ALU_MUL = 7.U(EXE_FUN_LEN.W)
  val ALU_MULH = 8.U(EXE_FUN_LEN.W)
  val ALU_MULHU = 9.U(EXE_FUN_LEN.W)
  val ALU_AND = 10.U(EXE_FUN_LEN.W)
  val ALU_SLL = 11.U(EXE_FUN_LEN.W)
  val ALU_ADD = 12.U(EXE_FUN_LEN.W)
  val ALU_SUB = 13.U(EXE_FUN_LEN.W)
  val ALU_SLTU = 14.U(EXE_FUN_LEN.W)
  val ALU_SLT = 15.U(EXE_FUN_LEN.W)
  val ALU_XOR = 16.U(EXE_FUN_LEN.W)
  val ALU_OR = 17.U(EXE_FUN_LEN.W)
  

  val OP1_LEN = 2
  val OP1_NONE = 0.U(OP1_LEN.W)
  val OP1_PC = 1.U(OP1_LEN.W)
  val OP1_RS1 = 2.U(OP1_LEN.W)

  val OP2_LEN = 2
  val OP2_NONE = 0.U(OP2_LEN.W)
  val OP2_IMM = 1.U(OP2_LEN.W)
  val OP2_RS2 = 2.U(OP2_LEN.W)
  
  val BR_LEN = 3
  val BR_NONE = 0.U(BR_LEN.W)
  val BR_BLT = 1.U(BR_LEN.W)
  val BR_BLTU = 2.U(BR_LEN.W)
  val BR_BGE = 3.U(BR_LEN.W)
  val BR_BGEU = 4.U(BR_LEN.W)
  val BR_BEQ = 5.U(BR_LEN.W)
  val BR_BNE = 6.U(BR_LEN.W)

  val MEM_LEN = 4
  val MEM_NONE = 0.U(MEM_LEN.W)
  val MEM_LW = 1.U(MEM_LEN.W)
  val MEM_LB = 2.U(MEM_LEN.W)
  val MEM_LBU = 3.U(MEM_LEN.W)
  val MEM_LH = 4.U(MEM_LEN.W)
  val MEM_LHU = 5.U(MEM_LEN.W)
  val MEM_SB = 6.U(MEM_LEN.W)
  val MEM_SW = 7.U(MEM_LEN.W)
  val MEM_SH = 8.U(MEM_LEN.W)

  val WB_LEN = 2
  val WB_NONE = 0.U(WB_LEN.W)
  val WB_EN = 1.U(WB_LEN.W)
  val WB_ALU = 2.U(WB_LEN.W)
  val WB_MEM = 3.U(WB_LEN.W)
  val WB_PC4 = 4.U(WB_LEN.W)

  val IMM_LEN = 3
  val IMM_NONE = 0.U(IMM_LEN.W)
  val IMM_I = 1.U(IMM_LEN.W)
  val IMM_S = 2.U(IMM_LEN.W)
  val IMM_B = 3.U(IMM_LEN.W)
  val IMM_U = 4.U(IMM_LEN.W)
  val IMM_J = 5.U(IMM_LEN.W)
}